# JVM

3. 如何解决线上GC频繁的问题?

   1. 查看时间点，

   2. 看是什么GC（Fgc，Ygc,GC的原因，什么种类的GC）

   3. 收集一切可以收集到的GC，然后根据Gc的理解，对问题进行分析

      > 了解当前代码什么时候上去的。

   Tool:   使用Jmap将堆内存导出来，  Java中自带的一个工具。

   

   Arsth：有时候是不一定可以打得进去的，Arsth通过在JVM中打进去一个点，对当前状态进行监控的，当jvm堆内存满的时候，不一定可以读取到日志信息的。

   

1. 通过Jmap将日志文件导出，放到本地，查看
2. 或者通过eclipse 中的MAT,进行查看
3. 查看最大对象，看是谁引用了这个最大对象，然后跟踪到对应的线程方法上面去就知道了。

5. 减速一下内存溢出的原因，如何排查线上问题？

   > 什么是内存溢出
   >
   > ​	超出了规定的内存大小
   >
   > 什么是内存泄漏
   >
   > ​	有一块内存，定义完之后，永远都用不到，永远也不会用它，丢了一个内存数，就像C中的野指针。

   线上设置JVM参数，当发生Full Gc的时候，dump出堆内存的快照。

   > 1. 使用PM命令看进程里面的映射关系
   > 2. 在linux中查看文件  /pre.c/进程    meminfo  cat 

6. 介绍一下垃圾回收算法

   引用计数

   标记清除（有内存碎片）、标记整理（无内存碎片，就是复制算法加整理算法）、复制是整理的子集

12. Happens-Before规则?

    Happens-Before规则就是对JVM的约束

16. 什么叫做阻塞队列的有界和无界，实际中有用过吗?

    > 有界和无界说的是在使用过程中，可否对队列设置大小，
    >
    > ArrayBlockingQueue: 可以在初始化的时候，对列表大小设置边界。

    ArrayBlockingQueue: 是一把锁

    LinkedBlockingQueue: 是两把锁，一把是前锁，一把是后锁。

    锁了，细度就上去了，并发也就上去了。

    什么时候使用ArrayBlockingQueue,什么时候使用LinkBlockingQueue;

    > 这个时候就涉及到了缓存行，因为ArrayBlockingQueue中可以使用缓存行。

    SynchronousQueue:容量为零的特殊队列。

# JVM  总有案例过一遍。













